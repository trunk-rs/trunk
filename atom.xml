<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Trunk | Build, bundle &amp; ship your Rust WASM application to the web</title>
	<link href="https://trunkrs.dev/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://trunkrs.dev"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2021-08-05T00:00:00+00:00</updated>
	<id>https://trunkrs.dev/atom.xml</id>
	<entry xml:lang="en">
		<title>Trunk v0.10 ‚Äì v0.13</title>
		<published>2021-08-05T00:00:00+00:00</published>
		<updated>2021-08-05T00:00:00+00:00</updated>
		<link href="https://trunkrs.dev/blog/v10-v13/" type="text/html"/>
		<id>https://trunkrs.dev/blog/v10-v13/</id>
		<content type="html">&lt;p&gt;Hello fellow Rustaceans! It&#x27;s been quite some time since our last blog post. We&#x27;ve seen 5 releases since then, so we&#x27;ve got a lot to cover.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;automatic-tool-downloads&quot;&gt;Automatic Tool Downloads&lt;&#x2F;h2&gt;
&lt;p&gt;After building wasm-opt integration for Trunk, &lt;code&gt;dnaka91&lt;&#x2F;code&gt; then built a system which is able to automatically download and install &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;wasm-opt&lt;&#x2F;code&gt; if they are missing from the host system. This system will check the version of &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt; being used by the parent application and will ensure that the versions match. External tools downloaded by this system are cached in a well-defined location based on the host OS.&lt;&#x2F;p&gt;
&lt;p&gt;Overall this feature lowers the barrier of entry for getting started with Trunk. It was quite common that folks in the community discord would drop in with an error message indicating that Trunk was not able to call &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt; (the error message was not so great). Now, such issues should be a thing of the past.&lt;&#x2F;p&gt;
&lt;p&gt;There is a lot of great potential with this feature. There has been some good discussion in the community around moving away from our current sass solution, which is to link to a C-based sass lib, and instead to use our new download system to pull down &lt;a href=&quot;https:&#x2F;&#x2F;sass-lang.com&#x2F;dart-sass&quot;&gt;dart-sass&lt;&#x2F;a&gt;. This is the primary sass implementation these days, getting all of the new features before any of the other implementations. More design work to be done here, but this could be a big win.&lt;&#x2F;p&gt;
&lt;p&gt;Not only does this apply to sass, but this could apply to any other integrations we build in the future. Especially in cases where the integration is a standalone binary which we can download and call. This will quite likely be an important piece of our plugin system once the plugin system is ready for prime time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tokio-axum&quot;&gt;Tokio &amp;amp; Axum&lt;&#x2F;h2&gt;
&lt;p&gt;Trunk has shipped with a static file server from the beginning. Somewhere along the way we added support for HTTP proxies, and then WebSocket proxies after that. Originally, Trunk was based on the &lt;code&gt;async-std&lt;&#x2F;code&gt; runtime, so we used &lt;code&gt;tide&lt;&#x2F;code&gt; for all things HTTP.&lt;&#x2F;p&gt;
&lt;p&gt;The Rust community evolves quickly. The async runtime ecosystem, even faster. Not long ago, the Tokio team released &lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2020-12-tokio-1-0&quot;&gt;Tokio 1.0&lt;&#x2F;a&gt;. This was a big win for the Rust ecosystem overall. Since then, they&#x27;ve continued to crank out new 1.x releases, along with new support libraries, io_uring support (love it), as well as a new server framework called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;axum&quot;&gt;Axum&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2021-07-announcing-axum&quot;&gt;blog post&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;All that to say, I decided to cut Trunk over to the Tokio ecosystem, and while I was in the middle finishing up that work, I found myself wishing that we had a nice, simple, ergonomic web framework for Tokio ... and then literally the very next day Axum was released. This couldn&#x27;t have come at a better time. Axum is built on Hyper &amp;amp; Tower, so it has direct interoperability with that entire ecosystem. This made the switch rather simple on the Trunk side.&lt;&#x2F;p&gt;
&lt;p&gt;I have to say, I&#x27;m quite stoked. Very happy with how this turned out for Trunk, and happy to see this new option come about for the Rust ecosystem. The wins here are obvious, but the biggest win is that we have a greater stability guarantee overall, and the success of the Tokio ecosystem to draw from.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;other-features-fixes&quot;&gt;Other Features &amp;amp; Fixes&lt;&#x2F;h2&gt;
&lt;p&gt;Lots of big wins so far, but these last few releases have also seen many other smaller features and fixes. Let&#x27;s take a look.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;indicatif&quot;&gt;&lt;code&gt;indicatif&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;After sinking more time than I care to admit, and finding myself frustrated rather often with &lt;code&gt;indicatif&lt;&#x2F;code&gt;, I decided to completely remove it from Trunk. Now, to be sure, &lt;code&gt;indicatif&lt;&#x2F;code&gt; is great, and its maintainer is quite literally a hero among the greater software community, but the difficulties I ran into here seemed to be more closely related to async interop.&lt;&#x2F;p&gt;
&lt;p&gt;Without going into too many details, deadlocks from progress bars, consoles not clearing properly, inflexibility of design, all of these things were causing me to spend more time on the console than spending time building other &lt;strong&gt;real&lt;&#x2F;strong&gt; features for Trunk. So, I decided to instead just use the good ol&#x27; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tracing&quot;&gt;tracing&lt;&#x2F;a&gt; crate, and now things are quite stable.&lt;&#x2F;p&gt;
&lt;p&gt;Truth be told, I would love to circle back at some point in the future and add a nicer console UI to Trunk. This is currently fairly low priority for me, as this is purely aesthetic. If you are passionate about such things, drop by our community discord and let us know!&lt;&#x2F;p&gt;
&lt;p&gt;There are many other features and fixes of note. Have a look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thedodd&#x2F;trunk&#x2F;blob&#x2F;master&#x2F;CHANGELOG.md&quot;&gt;changelog&lt;&#x2F;a&gt; for more details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;All in all, some great progress for Trunk. As far as Trunk&#x27;s future, the plugin system and exploring patterns around code splitting and HMR are the things I&#x27;m most excited about.&lt;&#x2F;p&gt;
&lt;p&gt;As a community, building web apps in Rust, finding the pain points, and then working together to fix them, that is how we make progress. Let&#x27;s keep on pushing forward!&lt;&#x2F;p&gt;
&lt;p&gt;Cheers!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Trunk v0.9.0</title>
		<published>2021-03-06T00:00:00+00:00</published>
		<updated>2021-03-06T00:00:00+00:00</updated>
		<link href="https://trunkrs.dev/blog/release-0-9-0/" type="text/html"/>
		<id>https://trunkrs.dev/blog/release-0-9-0/</id>
		<content type="html">&lt;p&gt;Hello fellow Rustaceans! As you may know, Trunk is a WASM web application bundler for Rust. It works out of the box with any web UI framework based on &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt;, and supports bundling of a good number of asset types including SASS&#x2F;SCSS, CSS, JS snippets, images, and more.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m happy to announce the release of Trunk &lt;code&gt;v0.9.0&lt;&#x2F;code&gt;. There are two major items to highlight here, let&#x27;s dig in.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;websocket-proxy-for-dev-server&quot;&gt;WebSocket Proxy for Dev Server&lt;&#x2F;h2&gt;
&lt;p&gt;First, shoutout to &lt;code&gt;hamza1311&lt;&#x2F;code&gt; for all of their work trailblazing this feature within Trunk, and also a shoutout to &lt;code&gt;jbg&lt;&#x2F;code&gt; for their work on &lt;code&gt;tide-websockets&lt;&#x2F;code&gt;, which is what we are using to power our new WebSocket proxy system.&lt;&#x2F;p&gt;
&lt;p&gt;The new WebSocket proxy is identical in structure to the way standard HTTP proxies are declared. On the CLI ‚Äî where only one proxy can be declared ‚Äì simply add the new &lt;code&gt;--proxy-ws&lt;&#x2F;code&gt; flag to enable WebSocket proxy mode.&lt;&#x2F;p&gt;
&lt;p&gt;In a &lt;code&gt;Trunk.toml&lt;&#x2F;code&gt; file ‚Äî where multiple proxies may be declared ‚Äî simply add the &lt;code&gt;ws = true&lt;&#x2F;code&gt; field to a proxy section to turn it into a WebSocket proxy, as such:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#323232;&quot;&gt;[[proxy]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#63a35c;&quot;&gt;backend &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#183691;&quot;&gt;&amp;quot;ws:&#x2F;&#x2F;localhost:9000&#x2F;api&#x2F;ws&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#63a35c;&quot;&gt;ws &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0086b3;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;integration-with-wasm-opt&quot;&gt;Integration with &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Shoutout to &lt;code&gt;dnaka91&lt;&#x2F;code&gt; for all of the work on this one. More details on wasm-opt itself can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;binaryen&quot;&gt;WebAssembly&#x2F;binaryen&lt;&#x2F;a&gt; repo.&lt;&#x2F;p&gt;
&lt;p&gt;Trunk now has an awesome integration with &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;. In your &lt;code&gt;index.html&lt;&#x2F;code&gt; file, simply add the &lt;code&gt;data-wasm-opt={level}&lt;&#x2F;code&gt; attribute to your &lt;code&gt;&amp;lt;link data-trunk rel=&amp;quot;rust&amp;quot; ...&#x2F;&amp;gt;&lt;&#x2F;code&gt; as described &lt;a href=&quot;https:&#x2F;&#x2F;trunkrs.dev&#x2F;assets&#x2F;#rust&quot;&gt;here in the docs&lt;&#x2F;a&gt;. The opt &lt;code&gt;level&lt;&#x2F;code&gt; can be any of the values &lt;code&gt;0&lt;&#x2F;code&gt;, &lt;code&gt;1&lt;&#x2F;code&gt;, &lt;code&gt;2&lt;&#x2F;code&gt;, &lt;code&gt;3&lt;&#x2F;code&gt;, &lt;code&gt;4&lt;&#x2F;code&gt;, &lt;code&gt;s&lt;&#x2F;code&gt; or &lt;code&gt;z&lt;&#x2F;code&gt; where &lt;code&gt;0&lt;&#x2F;code&gt; explicitly disables &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For now, &lt;code&gt;wasm-opt&lt;&#x2F;code&gt; will need to be manually installed on your system if you are planning on using it with Trunk. We already have an issue scoping out the work for automatically installing &lt;code&gt;wasm-opt&lt;&#x2F;code&gt; (along with &lt;code&gt;wasm-bindgen-cli&lt;&#x2F;code&gt; as well). This will come in a future release.&lt;&#x2F;p&gt;
&lt;p&gt;As of this release, the default opt level is &lt;code&gt;0&lt;&#x2F;code&gt;, effectively disabling &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;. This is primarily to maintain backwards compatibility given the fact that we do not yet automatically install &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;. After we&#x27;ve finished the work for automatic installation of &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;, we will quite likely set the default to something between &lt;code&gt;2&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;4&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The integration with &lt;code&gt;wasm-opt&lt;&#x2F;code&gt; was a blocker keeping some folks back from using Trunk (though it never precluded manual use of &lt;code&gt;wasm-opt&lt;&#x2F;code&gt;). Now that integration has landed, hopefully Trunk will be able to help more folks on their journey with Rust &amp;amp; WebAssembly.&lt;&#x2F;p&gt;
&lt;p&gt;Our new WebSocket support is also a major step forward for Trunk. WebSocket proxy support is a common need for folks building web applications, so being able to support this use case is a great step forward for the maturity of Trunk.&lt;&#x2F;p&gt;
&lt;p&gt;As community member &lt;code&gt;lukechu10&lt;&#x2F;code&gt; has pointed out, creating our own UI error overlay to communicate errors coming from the Trunk build system is now an option for us to pursue. Automatic UI reloading, WASM HMR (I hope), and an integrated UI error overlay are all excellent features for us to hack on next!&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m stoked, let&#x27;s continue to push this thing forward! If you are interested in getting involved, drop by our Discord server and say hello.&lt;&#x2F;p&gt;
&lt;p&gt;Cheers!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Design Thoughts ‚Äî Trunk Plugin System</title>
		<published>2021-02-05T00:00:00+00:00</published>
		<updated>2021-02-05T00:00:00+00:00</updated>
		<link href="https://trunkrs.dev/blog/plugin-system/" type="text/html"/>
		<id>https://trunkrs.dev/blog/plugin-system/</id>
		<content type="html">&lt;p&gt;Hello again! For this post, I would like to share my thoughts on a few possible design patterns for a Trunk plugin system. We will review a subset of the possible patterns based on some community discussion so far, looking at pros, cons, limitations and other things to consider along the way.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;why-plugins&quot;&gt;Why Plugins?&lt;&#x2F;h1&gt;
&lt;p&gt;The Trunk community has been discussing plans to introduce a plugin system for Trunk. A good question to ask is: why? There are definitely a few good reasons:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;There is a lot more work to be done on Trunk, and plugins would allow for folks to quickly and easily integrate with the Trunk build system in ways which are not yet supported.&lt;&#x2F;li&gt;
&lt;li&gt;Proprietary integration. Perhaps folks have some Trunk pipelines they would like to build, but they are not able to open source the code. This would provide for such cases.&lt;&#x2F;li&gt;
&lt;li&gt;Perhaps folks don&#x27;t want to take the time to contribute üò¨. The maintainers are too mean, too snarky, they always ask me to change things ... who knows?&lt;&#x2F;li&gt;
&lt;li&gt;Perhaps the use case is too niche, and the Trunk maintainers don&#x27;t think it should be in the code base.&lt;&#x2F;li&gt;
&lt;li&gt;A big one is maintenance. As Trunk grows and new use cases inevitably emerge, that will be more and more code to maintain, which may slow overall progress of core Trunk development.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;trunk-internals-abridged&quot;&gt;Trunk Internals (abridged)&lt;&#x2F;h1&gt;
&lt;p&gt;To have a meaningful discussion on possible Trunk plugin designs, let&#x27;s take a quick look at the internals of Trunk. There are 3 primary layers:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Configuration:&lt;&#x2F;strong&gt; this includes &lt;code&gt;Trunk.toml&lt;&#x2F;code&gt;, env vars, &amp;amp; CLI args&#x2F;opts. These are merged based on a cascade and then fed into the lower layers.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;CLI Commands:&lt;&#x2F;strong&gt; this is what tells Trunk what to do.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pipelines:&lt;&#x2F;strong&gt; all of the goodness of Trunk comes from the various pipelines we&#x27;ve created in this layer. This is where we process HTML, SASS&#x2F;SCSS, CSS, images, JS, etc.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;pipelines&quot;&gt;Pipelines&lt;&#x2F;h2&gt;
&lt;p&gt;The entire build system is a composition of various asynchronous pipelines. The very first pipeline is the HTML pipeline. This directly corresponds to the source HTML file (typically the &lt;code&gt;index.html&lt;&#x2F;code&gt;), and this pipeline is responsible for spawning various other pipelines based on the directives found in the source HTML. As a reminder, Trunk uses the &lt;code&gt;&amp;lt;link data-trunk rel=&amp;quot;{{TYPE}}&amp;quot; ..args.. &#x2F;&amp;gt;&lt;&#x2F;code&gt; pattern in the source HTML to declare asset pipelines which Trunk should process.&lt;&#x2F;p&gt;
&lt;p&gt;Each pipeline is given all of the data found in its corresponding &lt;code&gt;&amp;lt;link&amp;gt;&lt;&#x2F;code&gt;, along with some additional general data, like config and such. This is then spawned off as an async task. Currently there are no dependencies between pipelines, however the HTML pipeline will not complete until all of its spawned pipelines have finished.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately, each pipeline can do whatever it needs to do, producing various artifacts and writing them to the Trunk staging directory. Once a pipeline finishes, it will return a manifest of data along with a callback. That callback is called by Trunk providing a mutable reference to the will-be final HTML, and that callback can update the HTML in whatever way it needs, which is typically just to remove its original &lt;code&gt;link&lt;&#x2F;code&gt;, and maybe append some new data which points to newly generated artifacts. Once all of the pipelines have completed, Trunk will perform a few final tasks to provide a nice pristine &lt;code&gt;dist&lt;&#x2F;code&gt; dir ready to be served to the web.&lt;&#x2F;p&gt;
&lt;p&gt;Simply speaking, it could be said that Trunk is really just a system for running various sorts of pipelines&#x2F;tasks which operate on an HTML document.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;embedded-wasm-runtime&quot;&gt;Embedded WASM Runtime&lt;&#x2F;h1&gt;
&lt;p&gt;One pattern which is rather exciting would be to use an embedded WASM runtime like &lt;a href=&quot;https:&#x2F;&#x2F;wasmer.io&#x2F;&quot;&gt;https:&#x2F;&#x2F;wasmer.io&#x2F;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;wasmtime.dev&#x2F;&quot;&gt;https:&#x2F;&#x2F;wasmtime.dev&#x2F;&lt;&#x2F;a&gt; as the basis for our plugin system.&lt;&#x2F;p&gt;
&lt;p&gt;We could define a WASM import&#x2F;export interface where a WASM module may be loaded by Trunk, we query its Trunk ABI version, and then we call that module&#x27;s &lt;code&gt;main&lt;&#x2F;code&gt; function (or whatever we decide to call it) and pass it a compatible data structure corresponding to the data which normal Trunk pipelines would receive.&lt;&#x2F;p&gt;
&lt;p&gt;Those WASM plugin functions could return compatible data structures and manifests just like normal pipelines, and then we call another function on that WASM module, say &lt;code&gt;callback&lt;&#x2F;code&gt;, providing it HTML and then expecting HTML in response. This would be pretty damn close to the current pipeline system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;plugin-discovery&quot;&gt;Plugin Discovery&lt;&#x2F;h2&gt;
&lt;p&gt;Plugins could be declared in the &lt;code&gt;Trunk.toml&lt;&#x2F;code&gt;. A section of the TOML, say &lt;code&gt;[plugins]&lt;&#x2F;code&gt;, would allow users to declare a module by name, along with some info on how to download the corresponding WASM. Trunk would fetch and cache these modules, and then modules could be selected for use in the source HTML via a &lt;code&gt;&amp;lt;link data-trunk rel=&amp;quot;plugin&amp;quot; data-plugin=&amp;quot;{{NAME}}&amp;quot; ...&#x2F;&amp;gt;&lt;&#x2F;code&gt; or the like. This would give Trunk a fairly robust mechanism for detecting that a directive should use a plugin, and we would also know the name of the plugin as provided by the &lt;code&gt;data-plugin&lt;&#x2F;code&gt; attr.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve considered perhaps leveraging &lt;a href=&quot;https:&#x2F;&#x2F;wapm.io&#x2F;&quot;&gt;https:&#x2F;&#x2F;wapm.io&#x2F;&lt;&#x2F;a&gt; for this. Folks could use the WAPM registry for their Trunk plugins. Maybe we just allow folks to specify a URL (like the URL of an asset from a Github release) where Trunk can download the WASM module. Perhaps we support multiple patterns.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;capability-attrs&quot;&gt;Capability Attrs&lt;&#x2F;h2&gt;
&lt;p&gt;When a plugin is declared in the source HTML, attributes could be provided in the corresponding link which declare the &amp;quot;capabilities&amp;quot; which should be given to the plugin. Something like &lt;code&gt;data-plugin-capabilities=&amp;quot;capX,capY&amp;quot;&lt;&#x2F;code&gt;, or perhaps something more granular. Various capabilities could be listed, giving the Trunk user full control over what the plugin can and can not do.&lt;&#x2F;p&gt;
&lt;p&gt;Having used many JS bundlers and build tools, many of which have their own plugin systems, I have very often been quite paranoid about not knowing EXACTLY what those plugins are doing. Lots of fun exploits out there. This seems like a great way to help mitigate such issues. Plugins could declare the capabilities they need, and Trunk can abort a pipeline early if the user has not provided the needed capabilities, helping to ensure users don&#x27;t run into unexpected issues.&lt;&#x2F;p&gt;
&lt;p&gt;This seems quite nice. There are lots of additional features which could be developed along these lines. New Trunk capabilities could be exposed over time as we develop new features. I dig it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trunk-plugin-lib&quot;&gt;Trunk Plugin Lib&lt;&#x2F;h2&gt;
&lt;p&gt;Along with this approach we would release a &lt;code&gt;trunk-plugin&lt;&#x2F;code&gt; crate which does everything for you. The only thing plugin authors would need to do is write the actual business logic of their plugin. Some of the things it would do:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;it would have cargo features for opting into the various capabilities which Trunk can expose to plugins, and would expose code to actually utilize those capabilities from within the plugin.&lt;&#x2F;li&gt;
&lt;li&gt;opting into various capabilities would automatically update an exported WASM function to tell Trunk which capabilities the plugin needs.&lt;&#x2F;li&gt;
&lt;li&gt;all of the WIT business would be taken care of by this crate. Authors would not have to worry about how to move data across the WASM boundary.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;pros&quot;&gt;Pros&lt;&#x2F;h2&gt;
&lt;p&gt;Ok, so let&#x27;s recap the goodness.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;WASM gives us a universal runtime, so plugins could be written in any compatible WASM language (Rust, C, C++, Swift, Go, AssemblyScript, &amp;amp;c).&lt;&#x2F;li&gt;
&lt;li&gt;Plugins would only ever need to be compiled for one architecture: WASM.&lt;&#x2F;li&gt;
&lt;li&gt;Capability-based security. If a plugin needs network or filesystem access, this might be a good time to go review the code in the plugin.&lt;&#x2F;li&gt;
&lt;li&gt;The Trunk maintainers would publish a crate to handle all of the heavy lifting related to creating plugins.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cons&quot;&gt;Cons&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Building capabilities will take time and deeper design work, though this will be true for any plugin system.&lt;&#x2F;li&gt;
&lt;li&gt;WASM does not yet support async paradigms, so basically all plugins will need to be spawned onto an async threadpool. Not really a big deal.&lt;&#x2F;li&gt;
&lt;li&gt;We would be moving somewhat out of the happy and safe Rustacean tide pool and into the cold scary world of WASM, other package managers (potentially), and an unstable WASM&#x2F;WASI&#x2F;WIT set of specs ... though we are already a Rust WASM web bundler. Additionally, we would quite likely not use WASI at all, and instead expose our own set of capabilities.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;dynamic-linking-via-stable-abi&quot;&gt;Dynamic Linking (via Stable ABI)&lt;&#x2F;h1&gt;
&lt;p&gt;We&#x27;ve looked into using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rodrimati1992&#x2F;abi_stable_crates&#x2F;&quot;&gt;abi_stable_crates&lt;&#x2F;a&gt;. This would be Rust dynamic linking via a stable subset of the Rust ABI (provided by this crate, because Rust itself does not have a stable ABI), and then leveraging this crate&#x27;s runtime logic to verify the safety of dynamically linking to the various plugins.&lt;&#x2F;p&gt;
&lt;p&gt;We would need our own discovery system for this, and plugins would need to be built by Trunk (most likely), as they would need to be built for the host tripple. There would be a fair bit of overhead with this approach. It would not be as rigid as C FFI, and it would still be safe Rust&amp;lt;-&amp;gt;Rust communication, but we would need to use a limited subset of types at the boundary.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;just-don-t&quot;&gt;Just Don&#x27;t&lt;&#x2F;h1&gt;
&lt;p&gt;We could just not do a plugin system. There are already a few nice improvements we can make to the current process of adding new pipeline types. By my analysis, we should switch over to a dynamic dispatch model for the response data from pipelines. I only say this because the current approach uses enums (which I love), but folks unfamiliar with the code base may see this as tedious to update.&lt;&#x2F;p&gt;
&lt;p&gt;The process of adding new pipeline types is already pretty simple, we can make it even more simple. Perhaps this topic merits a blog post of its own.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;All in all, I&#x27;m pretty stoked about the possibility of using a WASM runtime for Trunk plugins. The security improvements (over other plugin models) are real, the simplicity of distributing ready to execute WASM is real, I dig it.&lt;&#x2F;p&gt;
&lt;p&gt;There is some good discussion over in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thedodd&#x2F;trunk&#x2F;issues&#x2F;104&quot;&gt;Trunk #104&lt;&#x2F;a&gt;, and more discussion to be had. This blog post should be seen as part of that discussion. If you have thoughts or ideas on this topic, please drop by and share. We would love to hear from you!&lt;&#x2F;p&gt;
&lt;p&gt;Cheers!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Trunk v0.8.0 &amp; Project Update</title>
		<published>2021-02-03T00:00:00+00:00</published>
		<updated>2021-02-03T00:00:00+00:00</updated>
		<link href="https://trunkrs.dev/blog/release-0-8-0/" type="text/html"/>
		<id>https://trunkrs.dev/blog/release-0-8-0/</id>
		<content type="html">&lt;p&gt;Hello fellow Rustaceans! Welcome to the very first official blog post of the Trunk community. In case you don&#x27;t know, Trunk is a WASM web application bundler for Rust. It works out of the box with any web UI framework based on &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt;, and supports bundling of a good number of asset types including SASS&#x2F;SCSS, CSS, JS snippets, images, and more. There&#x27;s a lot to cover here, so let&#x27;s dig in.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;new-site-new-blog&quot;&gt;New Site &amp;amp; New Blog&lt;&#x2F;h1&gt;
&lt;p&gt;First off, if you are reading this blog post, then you&#x27;ve found our new Trunk website. All of our documentation is here, and the maintainers team plans on continuing to expand this site, adding new documentation and improving the site as we go. This is a community driven website, so if you see things which you would like to improve, content you would like to add (including new blog posts), or any other sorts of changes, please open a PR! Just to make that process even easier, let&#x27;s talk about how the site is built.&lt;&#x2F;p&gt;
&lt;p&gt;We are using the excellent &lt;a href=&quot;https:&#x2F;&#x2F;getzola.org&quot;&gt;Zola static site engine&lt;&#x2F;a&gt;. It is another great Rust project. Putting together this entire site from nothing took only a few hours. Sure there&#x27;s not too much here, but the quality is quite solid, and Zola really delivered on providing a robust development process. Using Zola to make changes to this site will be quite simple for newcomers and experienced users alike.&lt;&#x2F;p&gt;
&lt;p&gt;We are also using the Zola &lt;a href=&quot;https:&#x2F;&#x2F;juice.huhu.io&#x2F;&quot;&gt;Juice theme&lt;&#x2F;a&gt;. I have to say, I quite like the theme, and very few changes were needed to make things work.&lt;&#x2F;p&gt;
&lt;p&gt;For now we are using Github Pages to host the site. This was so quick and easy, there are Github Actions which do most of the heavy lifting. Hard to beat that level of convenience.&lt;&#x2F;p&gt;
&lt;p&gt;Overall, adding a new blog post for maintainers and community members will typically be as simple as adding a new markdown file with your content ... AND THAT&#x27;S ALL. Doesn&#x27;t get easier than that. It is the hope of the maintainers team that community members will feel empowered to write a blog post on anything and everything related to Trunk. Use cases, future plans for contributions, pain points, areas where they would like to see Trunk improve, how to use Trunk with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;seed-rs&#x2F;seed&quot;&gt;Seed&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;yewstack&#x2F;yew&quot;&gt;Yew&lt;&#x2F;a&gt;, or any other project. The more content the better.&lt;&#x2F;p&gt;
&lt;p&gt;Last thing I will say about the site, we are in the process of adding some new art work. Right now we&#x27;ve got a placeholder Ferris holding down the fort. They&#x27;re doing a great job, but we&#x27;re looking for some Trunk specific art, images, Ferris logos, etc. We&#x27;ve got some discussion going on over in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thedodd&#x2F;trunk&#x2F;issues&#x2F;120&quot;&gt;Trunk #120&lt;&#x2F;a&gt;. I am especially excited about the possibility of an SVG of a bunch of little Ferris crabs packing a trunk full of sea shells, assets logos, scripts&#x2F;scrolls, coral chunks and the like. If you&#x27;ve got some skills on this front, and you would like to jump on this hype train, DO IT!!! &lt;strong&gt;We would love to show off your skills on the site.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;new-maintainers&quot;&gt;New Maintainers&lt;&#x2F;h1&gt;
&lt;p&gt;The biggest news we have, and probably one of the best things for the Trunk project itself, is that we have 3 new maintainers!!! üéâüçª Rakshith Ravi, Philip Peterson and Martin Kavik. I&#x27;m very excited to have these guys on the team, they&#x27;ve each already contributed in many ways to the Trunk project, and having a strong group of maintainers is very important for the long-term success of any open source project. We are all stronger together!&lt;&#x2F;p&gt;
&lt;p&gt;If you are interested in helping out as a maintainer, the best way to get started is with PR reviews, reviewing issues and making sure they are ready to be moved to the coding phase, and then actually getting your hands dirty with some code! Trunk so far has been able to maintain a pretty solid and enjoyable code base. Now is a great time to get involved.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;trunk-v0-8-0-has-landed&quot;&gt;Trunk v0.8.0 has Landed&lt;&#x2F;h1&gt;
&lt;p&gt;Trunk v0.8.0 has now been released. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thedodd&#x2F;trunk&#x2F;releases&#x2F;tag&#x2F;v0.8.0&quot;&gt;release page&lt;&#x2F;a&gt; for all of the details. In summary:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;trunk watch&lt;&#x2F;code&gt; &amp;amp; &lt;code&gt;trunk serve&lt;&#x2F;code&gt; commands now accept the &lt;code&gt;--watch&lt;&#x2F;code&gt; option which allows users to specify multiple different directories and files to be watched, triggering new builds as changes are detected. A community member &lt;code&gt;@malobre&lt;&#x2F;code&gt; knocked this one out.&lt;&#x2F;li&gt;
&lt;li&gt;Another community member &lt;code&gt;@DzenanJupic&lt;&#x2F;code&gt; has added the &lt;code&gt;inline&lt;&#x2F;code&gt; asset type. This allows users to target various file types and have their content &amp;quot;inlined&amp;quot; into the parent HTML document as-is. Go checkout the docs on the &lt;a href=&quot;https:&#x2F;&#x2F;trunkrs.dev&#x2F;assets&#x2F;#inline&quot;&gt;inline asset type&lt;&#x2F;a&gt; for more details (wow, felt great to be able to provide a link to the docs like that).&lt;&#x2F;li&gt;
&lt;li&gt;A community member &lt;code&gt;@hamza1311&lt;&#x2F;code&gt; &amp;amp; one of our maintainers &lt;code&gt;@philip-peterson&lt;&#x2F;code&gt; squashed a bug where old build artifacts would continually accumulate in the dist dir. That has now been fixed, and any time a successful build goes through, all of the old artifacts will be removed, and only the fresh new artifacts will exist in the &lt;code&gt;dist&lt;&#x2F;code&gt; dir.&lt;&#x2F;li&gt;
&lt;li&gt;Lastly, &lt;code&gt;@MartinKavik&lt;&#x2F;code&gt; fixed an infinite rebuild loop bug on Windows.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;immediate-plans&quot;&gt;Immediate Plans&lt;&#x2F;h1&gt;
&lt;p&gt;In the immediate term, we have a few community lead efforts for cutting Trunk over to the Tokio ecosystem. This is primarily to address our need for a robust WebSockets &amp;amp; SSE solution, and the Tokio community happens to have some pretty solid options on that front.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve also got another community lead effort on getting &lt;code&gt;wasm-opt&lt;&#x2F;code&gt; integrated into the standard Trunk build pipeline.&lt;&#x2F;p&gt;
&lt;p&gt;Both of these initiatives are exciting and will go far to provide an even better experience for folks building Rust WASM applications using Trunk.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;I am quite excited and optimistic about Rust&#x27;s future with WebAssembly. WebAssembly has a long way to go, but it has already come so far. Working together to continue making Rust the best option for WebAssembly, and to ship more safe, robust, and powerful Rust code to the web is definitely for the better as far as I can see.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;BONUS:&lt;&#x2F;strong&gt; head on over to &lt;a href=&quot;&#x2F;blog&#x2F;plugin-system&#x2F;&quot;&gt;the next blog post&lt;&#x2F;a&gt; where we discuss design patterns around a Trunk plugin system.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s keep on doing this. Cheers!&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
